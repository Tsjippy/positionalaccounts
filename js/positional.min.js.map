{"version":3,"file":"positional.min.js","mappings":"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","sources":["webpack://forms/../../login/js/partials/shared.js","webpack://forms/../../login/js/node_modules/@simplewebauthn/browser/esm/helpers/browserSupportsWebAuthn.js","webpack://forms/../../login/js/node_modules/@simplewebauthn/browser/esm/helpers/webAuthnError.js","webpack://forms/../../login/js/node_modules/@simplewebauthn/browser/esm/helpers/webAuthnAbortService.js","webpack://forms/../../login/js/node_modules/@simplewebauthn/browser/esm/helpers/bufferToBase64URLString.js","webpack://forms/../../login/js/node_modules/@simplewebauthn/browser/esm/helpers/base64URLStringToBuffer.js","webpack://forms/../../login/js/node_modules/@simplewebauthn/browser/esm/helpers/browserSupportsWebAuthnAutofill.js","webpack://forms/../../login/js/node_modules/@simplewebauthn/browser/esm/helpers/toPublicKeyCredentialDescriptor.js","webpack://forms/../../login/js/node_modules/@simplewebauthn/browser/esm/helpers/toAuthenticatorAttachment.js","webpack://forms/../../login/js/partials/webauth.js","webpack://forms/../../login/js/node_modules/@simplewebauthn/browser/esm/methods/startAuthentication.js","webpack://forms/../../login/js/node_modules/@simplewebauthn/browser/esm/helpers/identifyAuthenticationError.js","webpack://forms/../../login/js/node_modules/@simplewebauthn/browser/esm/helpers/isValidDomain.js","webpack://forms/./positional.js"],"sourcesContent":["export function closeMobileMenu(){\r\n\t//close mobile menu\r\n\tdocument.querySelectorAll('#site-navigation, #mobile-menu-control-wrapper').forEach(el=>el.classList.remove('toggled'));\r\n\tdocument.querySelector('body').classList.remove('mobile-menu-open');\r\n\tdocument.querySelectorAll(\"#mobile-menu-control-wrapper > button\").forEach(el=>el.ariaExpanded = 0);\r\n}\r\n\r\nexport function showMessage(message){\r\n\tdocument.querySelectorAll(\"#message\").forEach(el => el.innerHTML= DOMPurify.sanitize(message));\r\n}\r\n\r\nexport function togglePassworView(ev){\r\n\tev.stopImmediatePropagation();\r\n\t\r\n\tvar target\t= ev.target;\r\n\r\n\tif(ev.target.tagName == 'IMG'){\r\n\t\ttarget\t= ev.target.parentNode;\r\n\t}\r\n\r\n\tif(target.dataset.toggle == '0'){\r\n\t\ttarget.title\t\t\t\t\t\t\t\t= 'Hide password';\r\n\t\ttarget.dataset.toggle\t\t\t\t\t\t= '1';\r\n\t\ttarget.innerHTML\t\t\t\t\t\t\t= target.innerHTML.replace('invisible', 'visible');\r\n\t\ttarget.closest('.password').querySelector('input[type=\"password\"]').type\t= 'text';\r\n\t}else{\r\n\t\ttarget.title\t\t\t\t\t\t\t\t= 'Show password';\r\n\t\ttarget.dataset.toggle\t\t\t\t\t\t= '0';\r\n\t\ttarget.innerHTML\t\t\t\t\t\t\t= target.innerHTML.replace('visible', 'invisible');\r\n\t\ttarget.closest('.password').querySelector('input[type=\"text\"]').type\t= 'password';\r\n\t}\r\n}","/**\n * Determine if the browser is capable of Webauthn\n */\nexport function browserSupportsWebAuthn() {\n    return _browserSupportsWebAuthnInternals.stubThis(globalThis?.PublicKeyCredential !== undefined &&\n        typeof globalThis.PublicKeyCredential === 'function');\n}\n/**\n * Make it possible to stub the return value during testing\n * @ignore Don't include this in docs output\n */\nexport const _browserSupportsWebAuthnInternals = {\n    stubThis: (value) => value,\n};\n","/**\n * A custom Error used to return a more nuanced error detailing _why_ one of the eight documented\n * errors in the spec was raised after calling `navigator.credentials.create()` or\n * `navigator.credentials.get()`:\n *\n * - `AbortError`\n * - `ConstraintError`\n * - `InvalidStateError`\n * - `NotAllowedError`\n * - `NotSupportedError`\n * - `SecurityError`\n * - `TypeError`\n * - `UnknownError`\n *\n * Error messages were determined through investigation of the spec to determine under which\n * scenarios a given error would be raised.\n */\nexport class WebAuthnError extends Error {\n    constructor({ message, code, cause, name, }) {\n        // @ts-ignore: help Rollup understand that `cause` is okay to set\n        super(message, { cause });\n        Object.defineProperty(this, \"code\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.name = name ?? cause.name;\n        this.code = code;\n    }\n}\n","class BaseWebAuthnAbortService {\n    constructor() {\n        Object.defineProperty(this, \"controller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n    }\n    createNewAbortSignal() {\n        // Abort any existing calls to navigator.credentials.create() or navigator.credentials.get()\n        if (this.controller) {\n            const abortError = new Error('Cancelling existing WebAuthn API call for new one');\n            abortError.name = 'AbortError';\n            this.controller.abort(abortError);\n        }\n        const newController = new AbortController();\n        this.controller = newController;\n        return newController.signal;\n    }\n    cancelCeremony() {\n        if (this.controller) {\n            const abortError = new Error('Manually cancelling existing WebAuthn API call');\n            abortError.name = 'AbortError';\n            this.controller.abort(abortError);\n            this.controller = undefined;\n        }\n    }\n}\n/**\n * A service singleton to help ensure that only a single WebAuthn ceremony is active at a time.\n *\n * Users of **@simplewebauthn/browser** shouldn't typically need to use this, but it can help e.g.\n * developers building projects that use client-side routing to better control the behavior of\n * their UX in response to router navigation events.\n */\nexport const WebAuthnAbortService = new BaseWebAuthnAbortService();\n","/**\n * Convert the given array buffer into a Base64URL-encoded string. Ideal for converting various\n * credential response ArrayBuffers to string for sending back to the server as JSON.\n *\n * Helper method to compliment `base64URLStringToBuffer`\n */\nexport function bufferToBase64URLString(buffer) {\n    const bytes = new Uint8Array(buffer);\n    let str = '';\n    for (const charCode of bytes) {\n        str += String.fromCharCode(charCode);\n    }\n    const base64String = btoa(str);\n    return base64String.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n}\n","/**\n * Convert from a Base64URL-encoded string to an Array Buffer. Best used when converting a\n * credential ID from a JSON string to an ArrayBuffer, like in allowCredentials or\n * excludeCredentials\n *\n * Helper method to compliment `bufferToBase64URLString`\n */\nexport function base64URLStringToBuffer(base64URLString) {\n    // Convert from Base64URL to Base64\n    const base64 = base64URLString.replace(/-/g, '+').replace(/_/g, '/');\n    /**\n     * Pad with '=' until it's a multiple of four\n     * (4 - (85 % 4 = 1) = 3) % 4 = 3 padding\n     * (4 - (86 % 4 = 2) = 2) % 4 = 2 padding\n     * (4 - (87 % 4 = 3) = 1) % 4 = 1 padding\n     * (4 - (88 % 4 = 0) = 4) % 4 = 0 padding\n     */\n    const padLength = (4 - (base64.length % 4)) % 4;\n    const padded = base64.padEnd(base64.length + padLength, '=');\n    // Convert to a binary string\n    const binary = atob(padded);\n    // Convert binary string to buffer\n    const buffer = new ArrayBuffer(binary.length);\n    const bytes = new Uint8Array(buffer);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return buffer;\n}\n","import { browserSupportsWebAuthn } from './browserSupportsWebAuthn.js';\n/**\n * Determine if the browser supports conditional UI, so that WebAuthn credentials can\n * be shown to the user in the browser's typical password autofill popup.\n */\nexport function browserSupportsWebAuthnAutofill() {\n    if (!browserSupportsWebAuthn()) {\n        return _browserSupportsWebAuthnAutofillInternals.stubThis(new Promise((resolve) => resolve(false)));\n    }\n    /**\n     * I don't like the `as unknown` here but there's a `declare var PublicKeyCredential` in\n     * TS' DOM lib that's making it difficult for me to just go `as PublicKeyCredentialFuture` as I\n     * want. I think I'm fine with this for now since it's _supposed_ to be temporary, until TS types\n     * have a chance to catch up.\n     */\n    const globalPublicKeyCredential = globalThis\n        .PublicKeyCredential;\n    if (globalPublicKeyCredential?.isConditionalMediationAvailable === undefined) {\n        return _browserSupportsWebAuthnAutofillInternals.stubThis(new Promise((resolve) => resolve(false)));\n    }\n    return _browserSupportsWebAuthnAutofillInternals.stubThis(globalPublicKeyCredential.isConditionalMediationAvailable());\n}\n// Make it possible to stub the return value during testing\nexport const _browserSupportsWebAuthnAutofillInternals = {\n    stubThis: (value) => value,\n};\n","import { base64URLStringToBuffer } from './base64URLStringToBuffer.js';\nexport function toPublicKeyCredentialDescriptor(descriptor) {\n    const { id } = descriptor;\n    return {\n        ...descriptor,\n        id: base64URLStringToBuffer(id),\n        /**\n         * `descriptor.transports` is an array of our `AuthenticatorTransportFuture` that includes newer\n         * transports that TypeScript's DOM lib is ignorant of. Convince TS that our list of transports\n         * are fine to pass to WebAuthn since browsers will recognize the new value.\n         */\n        transports: descriptor.transports,\n    };\n}\n","const attachments = ['cross-platform', 'platform'];\n/**\n * If possible coerce a `string` value into a known `AuthenticatorAttachment`\n */\nexport function toAuthenticatorAttachment(attachment) {\n    if (!attachment) {\n        return;\n    }\n    if (attachments.indexOf(attachment) < 0) {\n        return;\n    }\n    return attachment;\n}\n","import { showMessage } from './shared.js';\r\n\r\nimport { startAuthentication } from '@simplewebauthn/browser';\r\n\r\nwindow.PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable().then(\r\n\tresult => {\r\n\t  if (!result) {\r\n\t\tconsole.log(\"No platform authenticator found. If your OS does not come with one, try using devtools to set one up.\");\r\n\t  }\r\n\t}\r\n);\r\n\r\n/**\r\n * Do a webauthn verification after loggin with username and password\r\n * \r\n * @param {string} username The user name to authenticate\r\n * @param {*} messageEl the html onject to display messages in\r\n */\r\nexport async function webAuthVerification(username){\r\n\ttry {\r\n\t\t// 1. Fetch authentication options from server\r\n\t\tlet formData\t\t\t\t= new FormData();\r\n\t\tformData.append('username', username);\r\n\r\n\t\tconst optionsJSON\t\t\t= await FormSubmit.fetchRestApi('login/auth_start', formData);\r\n\t\tif(!optionsJSON){\r\n\t\t\tthrow new Error('Fetching Server Challenge failed');\r\n\t\t}\r\n\r\n\t\t// Update message\r\n\t\tif(sim.login != undefined){\r\n\t\t\tsim.login.loadingScreen('Verifying credentials...');\r\n\t\t}\r\n\r\n\t\t// 2. Start authentication\r\n\t\tconst assertionResponse \t= await startAuthentication({ ...optionsJSON, useBrowserAutofill: true });\r\n\r\n\t\t// 3. Send to server for validation\r\n\t\tlet form \t\t\t\t\t= document.getElementById('loginform') ? document.getElementById('loginform') : undefined;\r\n\t\tformData\t\t\t\t\t= new FormData(form);\r\n\t\tformData.append('publicKeyCredential', btoa(JSON.stringify(assertionResponse)));\r\n\t\t\r\n\t\tlet response\t\t\t\t\t= await FormSubmit.fetchRestApi('login/auth_finish', formData);\r\n\t\tif(!response || response.verified){\r\n\t\t\tthrow new Error('Verification failed');\r\n\t\t}\r\n\r\n\t\tshowMessage('Verification successfull');\r\n\r\n\t\treturn true;\r\n\t} catch (error) {\r\n\t\tconsole.error('Authentication failed:', error);\r\n\r\n\t\tshowMessage(error);\r\n\r\n\t\treturn false;\r\n\t}\r\n}\r\n\r\n/**\r\n * Start passkey login without username\r\n * \r\n * @param {string} mediation the type of request\r\n * \r\n * @returns \r\n */\r\nexport let startConditionalRequest = async (mediation) => {\r\n\tif (window.PublicKeyCredential && PublicKeyCredential.isConditionalMediationAvailable) {\r\n\t\tconsole.log(\"Conditional UI is understood by the browser\");\r\n\t\tif (!await window.PublicKeyCredential.isConditionalMediationAvailable()) {\r\n\t\t\tconsole.log(\"Conditional UI is understood by your browser but not available\");\r\n\t\t\treturn;\r\n\t\t}\r\n\t} else {\r\n\t\tif (!navigator.credentials.conditionalMediationSupported) {\r\n\t\t\tconsole.log(\"Your browser does not implement Conditional UI (are you running the right chrome/safari version with the right flags?)\");\r\n\t\t\treturn;\r\n\t\t} else {\r\n\t\t\tconsole.log(\"This browser understand the old version of Conditional UI feature detection\");\r\n\t\t}\r\n\t}\r\n\r\n\tsim.login.loadingScreen('Performing passkey login');\r\n\r\n\tlet webauthResult =  await webAuthVerification('');\r\n\r\n\tif(webauthResult){\r\n\t\tshowMessage('Passkey login succesfull');\r\n\r\n\t\treturn await sim.login.requestLogin();\r\n\t}else{\r\n\t\tsim.login.reset();\r\n\r\n\t\tshowMessage('Passkey login failed, try using your username and password');\r\n\r\n\t\treturn false;\r\n\t}\r\n}\r\n\r\nexport async function checkWebauthnAvailable(){\r\n\tlet webauthnSupported\t= false;\r\n\t\r\n\tif (window.PublicKeyCredential) {\r\n\t\tlet available\t= await PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();\r\n\t\tif (available) {\r\n\t\t\twebauthnSupported = true;\r\n\t\t} else {\r\n\t\t\tconsole.log(\"WebAuthn supported, Platform Authenticator not supported.\");\r\n\t\t}\r\n\t} else {\r\n\t\tconsole.log(\"Not supported.\");\r\n\t}\r\n\r\n\treturn webauthnSupported;\r\n}","import { bufferToBase64URLString } from '../helpers/bufferToBase64URLString.js';\nimport { base64URLStringToBuffer } from '../helpers/base64URLStringToBuffer.js';\nimport { browserSupportsWebAuthn } from '../helpers/browserSupportsWebAuthn.js';\nimport { browserSupportsWebAuthnAutofill } from '../helpers/browserSupportsWebAuthnAutofill.js';\nimport { toPublicKeyCredentialDescriptor } from '../helpers/toPublicKeyCredentialDescriptor.js';\nimport { identifyAuthenticationError } from '../helpers/identifyAuthenticationError.js';\nimport { WebAuthnAbortService } from '../helpers/webAuthnAbortService.js';\nimport { toAuthenticatorAttachment } from '../helpers/toAuthenticatorAttachment.js';\n/**\n * Begin authenticator \"login\" via WebAuthn assertion\n *\n * @param optionsJSON Output from **@simplewebauthn/server**'s `generateAuthenticationOptions()`\n * @param useBrowserAutofill (Optional) Initialize conditional UI to enable logging in via browser autofill prompts. Defaults to `false`.\n * @param verifyBrowserAutofillInput (Optional) Ensure a suitable `<input>` element is present when `useBrowserAutofill` is `true`. Defaults to `true`.\n */\nexport async function startAuthentication(options) {\n    // @ts-ignore: Intentionally check for old call structure to warn about improper API call\n    if (!options.optionsJSON && options.challenge) {\n        console.warn('startAuthentication() was not called correctly. It will try to continue with the provided options, but this call should be refactored to use the expected call structure instead. See https://simplewebauthn.dev/docs/packages/browser#typeerror-cannot-read-properties-of-undefined-reading-challenge for more information.');\n        // @ts-ignore: Reassign the options, passed in as a positional argument, to the expected variable\n        options = { optionsJSON: options };\n    }\n    const { optionsJSON, useBrowserAutofill = false, verifyBrowserAutofillInput = true, } = options;\n    if (!browserSupportsWebAuthn()) {\n        throw new Error('WebAuthn is not supported in this browser');\n    }\n    // We need to avoid passing empty array to avoid blocking retrieval\n    // of public key\n    let allowCredentials;\n    if (optionsJSON.allowCredentials?.length !== 0) {\n        allowCredentials = optionsJSON.allowCredentials?.map(toPublicKeyCredentialDescriptor);\n    }\n    // We need to convert some values to Uint8Arrays before passing the credentials to the navigator\n    const publicKey = {\n        ...optionsJSON,\n        challenge: base64URLStringToBuffer(optionsJSON.challenge),\n        allowCredentials,\n    };\n    // Prepare options for `.get()`\n    const getOptions = {};\n    /**\n     * Set up the page to prompt the user to select a credential for authentication via the browser's\n     * input autofill mechanism.\n     */\n    if (useBrowserAutofill) {\n        if (!(await browserSupportsWebAuthnAutofill())) {\n            throw Error('Browser does not support WebAuthn autofill');\n        }\n        // Check for an <input> with \"webauthn\" in its `autocomplete` attribute\n        const eligibleInputs = document.querySelectorAll(\"input[autocomplete$='webauthn']\");\n        // WebAuthn autofill requires at least one valid input\n        if (eligibleInputs.length < 1 && verifyBrowserAutofillInput) {\n            throw Error('No <input> with \"webauthn\" as the only or last value in its `autocomplete` attribute was detected');\n        }\n        // `CredentialMediationRequirement` doesn't know about \"conditional\" yet as of\n        // typescript@4.6.3\n        getOptions.mediation = 'conditional';\n        // Conditional UI requires an empty allow list\n        publicKey.allowCredentials = [];\n    }\n    // Finalize options\n    getOptions.publicKey = publicKey;\n    // Set up the ability to cancel this request if the user attempts another\n    getOptions.signal = WebAuthnAbortService.createNewAbortSignal();\n    // Wait for the user to complete assertion\n    let credential;\n    try {\n        credential = (await navigator.credentials.get(getOptions));\n    }\n    catch (err) {\n        throw identifyAuthenticationError({ error: err, options: getOptions });\n    }\n    if (!credential) {\n        throw new Error('Authentication was not completed');\n    }\n    const { id, rawId, response, type } = credential;\n    let userHandle = undefined;\n    if (response.userHandle) {\n        userHandle = bufferToBase64URLString(response.userHandle);\n    }\n    // Convert values to base64 to make it easier to send back to the server\n    return {\n        id,\n        rawId: bufferToBase64URLString(rawId),\n        response: {\n            authenticatorData: bufferToBase64URLString(response.authenticatorData),\n            clientDataJSON: bufferToBase64URLString(response.clientDataJSON),\n            signature: bufferToBase64URLString(response.signature),\n            userHandle,\n        },\n        type,\n        clientExtensionResults: credential.getClientExtensionResults(),\n        authenticatorAttachment: toAuthenticatorAttachment(credential.authenticatorAttachment),\n    };\n}\n","import { isValidDomain } from './isValidDomain.js';\nimport { WebAuthnError } from './webAuthnError.js';\n/**\n * Attempt to intuit _why_ an error was raised after calling `navigator.credentials.get()`\n */\nexport function identifyAuthenticationError({ error, options, }) {\n    const { publicKey } = options;\n    if (!publicKey) {\n        throw Error('options was missing required publicKey property');\n    }\n    if (error.name === 'AbortError') {\n        if (options.signal instanceof AbortSignal) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 16)\n            return new WebAuthnError({\n                message: 'Authentication ceremony was sent an abort signal',\n                code: 'ERROR_CEREMONY_ABORTED',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'NotAllowedError') {\n        /**\n         * Pass the error directly through. Platforms are overloading this error beyond what the spec\n         * defines and we don't want to overwrite potentially useful error messages.\n         */\n        return new WebAuthnError({\n            message: error.message,\n            code: 'ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY',\n            cause: error,\n        });\n    }\n    else if (error.name === 'SecurityError') {\n        const effectiveDomain = globalThis.location.hostname;\n        if (!isValidDomain(effectiveDomain)) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-discover-from-external-source (Step 5)\n            return new WebAuthnError({\n                message: `${globalThis.location.hostname} is an invalid domain`,\n                code: 'ERROR_INVALID_DOMAIN',\n                cause: error,\n            });\n        }\n        else if (publicKey.rpId !== effectiveDomain) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-discover-from-external-source (Step 6)\n            return new WebAuthnError({\n                message: `The RP ID \"${publicKey.rpId}\" is invalid for this domain`,\n                code: 'ERROR_INVALID_RP_ID',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'UnknownError') {\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-get-assertion (Step 1)\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-get-assertion (Step 12)\n        return new WebAuthnError({\n            message: 'The authenticator was unable to process the specified options, or could not create a new assertion signature',\n            code: 'ERROR_AUTHENTICATOR_GENERAL_ERROR',\n            cause: error,\n        });\n    }\n    return error;\n}\n","/**\n * A simple test to determine if a hostname is a properly-formatted domain name\n *\n * A \"valid domain\" is defined here: https://url.spec.whatwg.org/#valid-domain\n *\n * Regex sourced from here:\n * https://www.oreilly.com/library/view/regular-expressions-cookbook/9781449327453/ch08s15.html\n */\nexport function isValidDomain(hostname) {\n    return (\n    // Consider localhost valid as well since it's okay wrt Secure Contexts\n    hostname === 'localhost' ||\n        /^([a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,}$/i.test(hostname));\n}\n","import {webAuthVerification} from './../../login/js/partials/webauth.js';\r\n\r\nasync function verifyAccountSwitch(target){\r\n    let targetAccountId = target.dataset.accountid;\r\n    let nonce           = target.dataset.nonce;\r\n\r\n    let loader          = Main.showLoader(target);\r\n\r\n    if(await webAuthVerification(targetAccountId)){\r\n        let formData    = new FormData();\r\n\r\n        formData.append('switch-account', targetAccountId);\r\n\r\n        formData.append('nonce', nonce);\r\n\r\n        let response\t= await FormSubmit.fetchRestApi('positional/switch_account', formData);\r\n\r\n\t    if(response){\r\n            Main.displayMessage(response);\r\n\r\n            window.location.href   = window.location.href;\r\n\r\n            return;\r\n        }\r\n    }\r\n\r\n    Main.displayMessage(\"Passkey login for the account failed.\\nLogging out...\", 'error');\r\n\r\n    // If the passkey login failed, we log out the user\r\n    // This is to ensure that the user can try logging in with a different method\r\n    document.querySelectorAll(`.logout`).forEach((el) => el.click());\r\n    \r\n    let menu     = loader.closest('.menu-item-has-children');\r\n    loader.remove();\r\n    if(menu.querySelectorAll(`button`).length == 0){\r\n        menu.remove();\r\n    }\r\n}\r\n\r\nconsole.log('Positional accounts script loaded');\r\n\r\ndocument.addEventListener(\"click\", function(event) {\r\n    if(event.target.matches(`.account-switcher`)){\r\n        event.stopImmediatePropagation();\r\n        verifyAccountSwitch(event.target);\r\n    }\r\n});"],"names":["message","document","querySelectorAll","forEach","el","innerHTML","DOMPurify","sanitize","_browserSupportsWebAuthnInternals","stubThis","undefined","globalThis","PublicKeyCredential","value","Error","constructor","code","cause","name","super","Object","defineProperty","this","enumerable","configurable","writable","createNewAbortSignal","controller","abortError","abort","newController","AbortController","signal","cancelCeremony","buffer","bytes","Uint8Array","str","charCode","String","fromCharCode","btoa","replace","base64URLString","base64","padLength","length","padded","padEnd","binary","atob","ArrayBuffer","i","charCodeAt","_browserSupportsWebAuthnAutofillInternals","descriptor","id","transports","attachments","attachment","indexOf","async","webAuthVerification","username","formData","FormData","append","optionsJSON","FormSubmit","fetchRestApi","sim","login","loadingScreen","assertionResponse","options","challenge","console","warn","useBrowserAutofill","verifyBrowserAutofillInput","allowCredentials","map","publicKey","getOptions","Promise","resolve","globalPublicKeyCredential","isConditionalMediationAvailable","browserSupportsWebAuthnAutofill","mediation","credential","navigator","credentials","get","err","error","AbortSignal","effectiveDomain","location","hostname","test","rpId","identifyAuthenticationError","rawId","response","type","userHandle","authenticatorData","clientDataJSON","signature","clientExtensionResults","getClientExtensionResults","authenticatorAttachment","startAuthentication","form","getElementById","JSON","stringify","verified","window","isUserVerifyingPlatformAuthenticatorAvailable","then","result","log","addEventListener","event","target","matches","stopImmediatePropagation","targetAccountId","dataset","accountid","nonce","loader","Main","showLoader","displayMessage","href","click","menu","closest","remove","verifyAccountSwitch"],"sourceRoot":""}